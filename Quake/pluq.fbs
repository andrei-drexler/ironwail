// pluq.fbs - PluQ FlatBuffers Schema
// Three-channel IPC protocol for Quake game state streaming

namespace PluQ;

// ============================================================================
// COMMON TYPES
// ============================================================================

struct Vec3 {
  x: float;
  y: float;
  z: float;
}

// ============================================================================
// RESOURCES CHANNEL - Resource streaming (on-demand or bulk)
// Frontend can either:
//  1. Request specific resources by ID (REQ/REP)
//  2. Receive bulk resource dump during map load (PUB/SUB)
// ============================================================================

enum ResourceType : byte {
  MapStart = 0,
  Texture = 1,
  Model = 2,
  BSPVertices = 3,
  BSPFaces = 4,
  Lightmap = 5,
  MapComplete = 6
}

// Frontend → Backend: Request a specific resource
table ResourceRequest {
  resource_type: ResourceType;
  resource_id: uint32;
  resource_name: string;  // Optional: request by name instead of ID
}

table MapStart {
  mapname: string;
  num_textures: uint32;
  num_models: uint32;
  num_lightmaps: uint32;

  // Resource lookup table - frontend can use this to decide:
  // 1. Load locally (if it has pak files)
  // 2. Request from backend (if it doesn't)
  resources: [ResourceLookup];
}

table Texture {
  id: uint32;
  name: string;
  width: uint16;
  height: uint16;
  format: byte;  // 0=RGBA, 1=RGB, 2=Indexed
  pixels: [ubyte];
}

table Model {
  id: uint32;
  name: string;
  num_vertices: uint32;
  num_triangles: uint32;
  num_frames: uint32;
  vertices: [float];      // Packed: x,y,z for each vertex
  triangles: [uint16];    // Triangle indices
  texcoords: [float];     // UV coordinates
  normals: [float];       // Normals
}

table BSPVertices {
  vertices: [Vec3];
}

table BSPFace {
  plane_id: uint32;
  side: byte;
  first_edge: uint32;
  num_edges: uint16;
  texture_id: uint16;
  lightmap_offset: uint32;
  styles: [byte];
}

table BSPFaces {
  faces: [BSPFace];
}

table Lightmap {
  id: uint32;
  width: uint16;
  height: uint16;
  data: [ubyte];  // RGB lightmap data
}

table MapComplete {
  total_resources: uint32;
}

union ResourceData {
  MapStart,
  Texture,
  Model,
  BSPVertices,
  BSPFaces,
  Lightmap,
  MapComplete
}

// Backend → Frontend: Resource response (REP) or broadcast (PUB)
table ResourceMessage {
  type: ResourceType;
  sequence: uint32;
  data: ResourceData;
}

// Resource lookup table (sent with MapStart)
table ResourceLookup {
  id: uint32;
  type: ResourceType;
  name: string;
  size: uint32;  // Size in bytes (for progress bars)
}

// ============================================================================
// GAMEPLAY CHANNEL - Runtime game state (every frame)
// ============================================================================

table Entity {
  origin: Vec3;
  angles: Vec3;
  model_id: uint16;
  frame: byte;
  colormap: byte;
  skin: byte;
  effects: uint32;
  alpha: float;
}

table GameplayFrame {
  frame_number: uint32;
  timestamp: double;

  // View state
  view_origin: Vec3;
  view_angles: Vec3;

  // Player stats
  health: int16;
  armor: int16;
  weapon: byte;
  ammo: uint16;

  // Game state
  paused: bool;
  in_game: bool;

  // Entities
  entities: [Entity];
}

// ============================================================================
// INPUT CHANNEL - User input (from frontend to backend)
// ============================================================================

table InputCommand {
  sequence: uint32;
  timestamp: double;

  // Movement
  forward_move: float;
  side_move: float;
  up_move: float;

  // View
  view_angles: Vec3;

  // Buttons (bitfield)
  buttons: uint32;

  // Impulse
  impulse: byte;

  // Console command (optional)
  cmd_text: string;
}

// ============================================================================
// ROOT TYPES (one per channel)
// ============================================================================

root_type ResourceMessage;
// Also valid root types for other channels:
// root_type GameplayFrame;
// root_type InputCommand;
